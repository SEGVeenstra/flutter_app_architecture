// Mocks generated by Mockito 5.0.17 from annotations
// in counter_domain/test/mocks.dart.
// Do not manually edit this file.

import 'dart:async' as _i4;

import 'package:counter_domain/src/counter/entities/number.dart' as _i3;
import 'package:counter_domain/src/counter/repositories/counter_repository.dart'
    as _i2;
import 'package:mockito/mockito.dart' as _i1;

// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types

class _FakeCounterRepositoryUpdated_0 extends _i1.Fake
    implements _i2.CounterRepositoryUpdated {}

class _FakeNumber_1 extends _i1.Fake implements _i3.Number {}

class _FakeStreamSubscription_2<T> extends _i1.Fake
    implements _i4.StreamSubscription<T> {}

/// A class which mocks [CounterRepository].
///
/// See the documentation for Mockito's code generation for more information.
class MockCounterRepository extends _i1.Mock implements _i2.CounterRepository {
  MockCounterRepository() {
    _i1.throwOnMissingStub(this);
  }

  @override
  bool get isBroadcast =>
      (super.noSuchMethod(Invocation.getter(#isBroadcast), returnValue: false)
          as bool);
  @override
  _i4.Future<int> get length => (super.noSuchMethod(Invocation.getter(#length),
      returnValue: Future<int>.value(0)) as _i4.Future<int>);
  @override
  _i4.Future<bool> get isEmpty =>
      (super.noSuchMethod(Invocation.getter(#isEmpty),
          returnValue: Future<bool>.value(false)) as _i4.Future<bool>);
  @override
  _i4.Future<_i2.CounterRepositoryUpdated> get first =>
      (super.noSuchMethod(Invocation.getter(#first),
              returnValue: Future<_i2.CounterRepositoryUpdated>.value(
                  _FakeCounterRepositoryUpdated_0()))
          as _i4.Future<_i2.CounterRepositoryUpdated>);
  @override
  _i4.Future<_i2.CounterRepositoryUpdated> get last =>
      (super.noSuchMethod(Invocation.getter(#last),
              returnValue: Future<_i2.CounterRepositoryUpdated>.value(
                  _FakeCounterRepositoryUpdated_0()))
          as _i4.Future<_i2.CounterRepositoryUpdated>);
  @override
  _i4.Future<_i2.CounterRepositoryUpdated> get single =>
      (super.noSuchMethod(Invocation.getter(#single),
              returnValue: Future<_i2.CounterRepositoryUpdated>.value(
                  _FakeCounterRepositoryUpdated_0()))
          as _i4.Future<_i2.CounterRepositoryUpdated>);
  @override
  _i4.Future<void> storeNumber(_i3.Number? number) =>
      (super.noSuchMethod(Invocation.method(#storeNumber, [number]),
          returnValue: Future<void>.value(),
          returnValueForMissingStub: Future<void>.value()) as _i4.Future<void>);
  @override
  _i4.Future<_i3.Number> getNumber() =>
      (super.noSuchMethod(Invocation.method(#getNumber, []),
              returnValue: Future<_i3.Number>.value(_FakeNumber_1()))
          as _i4.Future<_i3.Number>);
  @override
  _i4.Stream<_i2.CounterRepositoryUpdated> asBroadcastStream(
          {void Function(_i4.StreamSubscription<_i2.CounterRepositoryUpdated>)?
              onListen,
          void Function(_i4.StreamSubscription<_i2.CounterRepositoryUpdated>)?
              onCancel}) =>
      (super.noSuchMethod(
              Invocation.method(#asBroadcastStream, [],
                  {#onListen: onListen, #onCancel: onCancel}),
              returnValue: Stream<_i2.CounterRepositoryUpdated>.empty())
          as _i4.Stream<_i2.CounterRepositoryUpdated>);
  @override
  _i4.StreamSubscription<_i2.CounterRepositoryUpdated> listen(
          void Function(_i2.CounterRepositoryUpdated)? onData,
          {Function? onError,
          void Function()? onDone,
          bool? cancelOnError}) =>
      (super.noSuchMethod(
              Invocation.method(#listen, [
                onData
              ], {
                #onError: onError,
                #onDone: onDone,
                #cancelOnError: cancelOnError
              }),
              returnValue:
                  _FakeStreamSubscription_2<_i2.CounterRepositoryUpdated>())
          as _i4.StreamSubscription<_i2.CounterRepositoryUpdated>);
  @override
  _i4.Stream<_i2.CounterRepositoryUpdated> where(
          bool Function(_i2.CounterRepositoryUpdated)? test) =>
      (super.noSuchMethod(Invocation.method(#where, [test]),
              returnValue: Stream<_i2.CounterRepositoryUpdated>.empty())
          as _i4.Stream<_i2.CounterRepositoryUpdated>);
  @override
  _i4.Stream<S> map<S>(S Function(_i2.CounterRepositoryUpdated)? convert) =>
      (super.noSuchMethod(Invocation.method(#map, [convert]),
          returnValue: Stream<S>.empty()) as _i4.Stream<S>);
  @override
  _i4.Stream<E> asyncMap<E>(
          _i4.FutureOr<E>? Function(_i2.CounterRepositoryUpdated)? convert) =>
      (super.noSuchMethod(Invocation.method(#asyncMap, [convert]),
          returnValue: Stream<E>.empty()) as _i4.Stream<E>);
  @override
  _i4.Stream<E> asyncExpand<E>(
          _i4.Stream<E>? Function(_i2.CounterRepositoryUpdated)? convert) =>
      (super.noSuchMethod(Invocation.method(#asyncExpand, [convert]),
          returnValue: Stream<E>.empty()) as _i4.Stream<E>);
  @override
  _i4.Stream<_i2.CounterRepositoryUpdated> handleError(Function? onError,
          {bool Function(dynamic)? test}) =>
      (super.noSuchMethod(
              Invocation.method(#handleError, [onError], {#test: test}),
              returnValue: Stream<_i2.CounterRepositoryUpdated>.empty())
          as _i4.Stream<_i2.CounterRepositoryUpdated>);
  @override
  _i4.Stream<S> expand<S>(
          Iterable<S> Function(_i2.CounterRepositoryUpdated)? convert) =>
      (super.noSuchMethod(Invocation.method(#expand, [convert]),
          returnValue: Stream<S>.empty()) as _i4.Stream<S>);
  @override
  _i4.Future<dynamic> pipe(
          _i4.StreamConsumer<_i2.CounterRepositoryUpdated>? streamConsumer) =>
      (super.noSuchMethod(Invocation.method(#pipe, [streamConsumer]),
          returnValue: Future<dynamic>.value()) as _i4.Future<dynamic>);
  @override
  _i4.Stream<S> transform<S>(
          _i4.StreamTransformer<_i2.CounterRepositoryUpdated, S>?
              streamTransformer) =>
      (super.noSuchMethod(Invocation.method(#transform, [streamTransformer]),
          returnValue: Stream<S>.empty()) as _i4.Stream<S>);
  @override
  _i4.Future<_i2.CounterRepositoryUpdated> reduce(
          _i2.CounterRepositoryUpdated Function(
                  _i2.CounterRepositoryUpdated, _i2.CounterRepositoryUpdated)?
              combine) =>
      (super.noSuchMethod(Invocation.method(#reduce, [combine]),
              returnValue: Future<_i2.CounterRepositoryUpdated>.value(
                  _FakeCounterRepositoryUpdated_0()))
          as _i4.Future<_i2.CounterRepositoryUpdated>);
  @override
  _i4.Future<S> fold<S>(S? initialValue,
          S Function(S, _i2.CounterRepositoryUpdated)? combine) =>
      (super.noSuchMethod(Invocation.method(#fold, [initialValue, combine]),
          returnValue: Future<S>.value(null)) as _i4.Future<S>);
  @override
  _i4.Future<String> join([String? separator = r'']) =>
      (super.noSuchMethod(Invocation.method(#join, [separator]),
          returnValue: Future<String>.value('')) as _i4.Future<String>);
  @override
  _i4.Future<bool> contains(Object? needle) =>
      (super.noSuchMethod(Invocation.method(#contains, [needle]),
          returnValue: Future<bool>.value(false)) as _i4.Future<bool>);
  @override
  _i4.Future<dynamic> forEach(
          void Function(_i2.CounterRepositoryUpdated)? action) =>
      (super.noSuchMethod(Invocation.method(#forEach, [action]),
          returnValue: Future<dynamic>.value()) as _i4.Future<dynamic>);
  @override
  _i4.Future<bool> every(bool Function(_i2.CounterRepositoryUpdated)? test) =>
      (super.noSuchMethod(Invocation.method(#every, [test]),
          returnValue: Future<bool>.value(false)) as _i4.Future<bool>);
  @override
  _i4.Future<bool> any(bool Function(_i2.CounterRepositoryUpdated)? test) =>
      (super.noSuchMethod(Invocation.method(#any, [test]),
          returnValue: Future<bool>.value(false)) as _i4.Future<bool>);
  @override
  _i4.Stream<R> cast<R>() => (super.noSuchMethod(Invocation.method(#cast, []),
      returnValue: Stream<R>.empty()) as _i4.Stream<R>);
  @override
  _i4.Future<List<_i2.CounterRepositoryUpdated>> toList() =>
      (super.noSuchMethod(Invocation.method(#toList, []),
              returnValue: Future<List<_i2.CounterRepositoryUpdated>>.value(
                  <_i2.CounterRepositoryUpdated>[]))
          as _i4.Future<List<_i2.CounterRepositoryUpdated>>);
  @override
  _i4.Future<Set<_i2.CounterRepositoryUpdated>> toSet() =>
      (super.noSuchMethod(Invocation.method(#toSet, []),
              returnValue: Future<Set<_i2.CounterRepositoryUpdated>>.value(
                  <_i2.CounterRepositoryUpdated>{}))
          as _i4.Future<Set<_i2.CounterRepositoryUpdated>>);
  @override
  _i4.Future<E> drain<E>([E? futureValue]) =>
      (super.noSuchMethod(Invocation.method(#drain, [futureValue]),
          returnValue: Future<E>.value(null)) as _i4.Future<E>);
  @override
  _i4.Stream<_i2.CounterRepositoryUpdated> take(int? count) =>
      (super.noSuchMethod(Invocation.method(#take, [count]),
              returnValue: Stream<_i2.CounterRepositoryUpdated>.empty())
          as _i4.Stream<_i2.CounterRepositoryUpdated>);
  @override
  _i4.Stream<_i2.CounterRepositoryUpdated> takeWhile(
          bool Function(_i2.CounterRepositoryUpdated)? test) =>
      (super.noSuchMethod(Invocation.method(#takeWhile, [test]),
              returnValue: Stream<_i2.CounterRepositoryUpdated>.empty())
          as _i4.Stream<_i2.CounterRepositoryUpdated>);
  @override
  _i4.Stream<_i2.CounterRepositoryUpdated> skip(int? count) =>
      (super.noSuchMethod(Invocation.method(#skip, [count]),
              returnValue: Stream<_i2.CounterRepositoryUpdated>.empty())
          as _i4.Stream<_i2.CounterRepositoryUpdated>);
  @override
  _i4.Stream<_i2.CounterRepositoryUpdated> skipWhile(
          bool Function(_i2.CounterRepositoryUpdated)? test) =>
      (super.noSuchMethod(Invocation.method(#skipWhile, [test]),
              returnValue: Stream<_i2.CounterRepositoryUpdated>.empty())
          as _i4.Stream<_i2.CounterRepositoryUpdated>);
  @override
  _i4.Stream<_i2.CounterRepositoryUpdated> distinct(
          [bool Function(
                  _i2.CounterRepositoryUpdated, _i2.CounterRepositoryUpdated)?
              equals]) =>
      (super.noSuchMethod(Invocation.method(#distinct, [equals]),
              returnValue: Stream<_i2.CounterRepositoryUpdated>.empty())
          as _i4.Stream<_i2.CounterRepositoryUpdated>);
  @override
  _i4.Future<_i2.CounterRepositoryUpdated> firstWhere(
          bool Function(_i2.CounterRepositoryUpdated)? test,
          {_i2.CounterRepositoryUpdated Function()? orElse}) =>
      (super.noSuchMethod(
              Invocation.method(#firstWhere, [test], {#orElse: orElse}),
              returnValue: Future<_i2.CounterRepositoryUpdated>.value(
                  _FakeCounterRepositoryUpdated_0()))
          as _i4.Future<_i2.CounterRepositoryUpdated>);
  @override
  _i4.Future<_i2.CounterRepositoryUpdated> lastWhere(
          bool Function(_i2.CounterRepositoryUpdated)? test,
          {_i2.CounterRepositoryUpdated Function()? orElse}) =>
      (super.noSuchMethod(
              Invocation.method(#lastWhere, [test], {#orElse: orElse}),
              returnValue: Future<_i2.CounterRepositoryUpdated>.value(
                  _FakeCounterRepositoryUpdated_0()))
          as _i4.Future<_i2.CounterRepositoryUpdated>);
  @override
  _i4.Future<_i2.CounterRepositoryUpdated> singleWhere(
          bool Function(_i2.CounterRepositoryUpdated)? test,
          {_i2.CounterRepositoryUpdated Function()? orElse}) =>
      (super.noSuchMethod(
              Invocation.method(#singleWhere, [test], {#orElse: orElse}),
              returnValue: Future<_i2.CounterRepositoryUpdated>.value(
                  _FakeCounterRepositoryUpdated_0()))
          as _i4.Future<_i2.CounterRepositoryUpdated>);
  @override
  _i4.Future<_i2.CounterRepositoryUpdated> elementAt(int? index) =>
      (super.noSuchMethod(Invocation.method(#elementAt, [index]),
              returnValue: Future<_i2.CounterRepositoryUpdated>.value(
                  _FakeCounterRepositoryUpdated_0()))
          as _i4.Future<_i2.CounterRepositoryUpdated>);
  @override
  _i4.Stream<_i2.CounterRepositoryUpdated> timeout(Duration? timeLimit,
          {void Function(_i4.EventSink<_i2.CounterRepositoryUpdated>)?
              onTimeout}) =>
      (super.noSuchMethod(
              Invocation.method(#timeout, [timeLimit], {#onTimeout: onTimeout}),
              returnValue: Stream<_i2.CounterRepositoryUpdated>.empty())
          as _i4.Stream<_i2.CounterRepositoryUpdated>);
}
